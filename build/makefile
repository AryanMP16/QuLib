#All paths relative to the SUMMERPROJECT24/build directory

DEPENDENCY_DIR = ../dependencies#don't fucking ask
REQUIRED_FILE = $(DEPENDENCY_DIR)/2a313e2f-0e6b-4d18-8929-d18dd7dd6c7e-1686176447886.jpg

ifeq ($(wildcard $(REQUIRED_FILE)),)
$(error Required file "$(REQUIRED_FILE)" not found.)
endif

IDIR = ../include#include directories
CC = g++ #compiler
CFLAGS = -I$(IDIR) -std=c++17#compiler flags

ODIR = obj#where object files will be stored
SDIR = ../src#where source files are stored

# Include path for Python headers
PYTHON_INCLUDE = $(shell python3 -c "from sysconfig import get_paths as gp; print(gp()['include'])")
NUMPY_INCLUDE = $(shell python3 -c "import numpy; print(numpy.get_include())")

CFLAGS += -I$(NUMPY_INCLUDE)

# Library path for Python libraries
PYTHON_LIB = $(shell python3 -c "from sysconfig import get_paths as gp; print(gp()['platlib'])")

LIBS = -lm -lpython3.8 #libraries to link against. -lm is math library, -lpython3.8 is Python library

_DEPS = complex.h matrix.h Runge_Kutta_4.h matplotlibcpp.h#list of all header files
#note on variables: they are declared just like in shell, e.g., identifier=value
#	however, in shell, to do variable expansion, you write $identifier.
#	in make, you do variable expansion by writing $(identifier) or ${identifier}

#note on command substitution: in shell, you can do command substitution with the
#	syntax $(command params...). In make, there are 2 types of command substitution:
#	If the command that (in shell) would be inside your parentheses is a command built in to make
#	(that is, it's native to make) then the syntax is exactly the same:
#	$(command params...)
#	If the command is not built in to make, but is, instead, a shell command, you can run:
#	$(shell command params...)

#note on %: in make, % is a 'wildcard' character used in pattern matching. It matches:
#	any non-empty substring

#note on patsubst:
#	$(patsubst pattern,replacement,text)
#	Finds whitespace-separated words in 'text' that match 'pattern' and replaces them with
#	'replacement'
#	E.g., $(patsubst %.c,%.o,x.c.c bar.c) produces: 'x.c.o bar.o'
DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))

_OBJ = main.o
OBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))

#note on make rules:
#target ... : prerequisites ...
#	recipe
#	...
#	...
#
#target is (often .o or .exe) file that will be generated by the program
#prerequisites are files used as inputs to generate the target
#recipe is an action that make carries out

#another important note on 'rules':
#	it can be confusing to think of rules as functions because then you think 'where's the function call?'
#	because in normal programming languages, functions and their calls are separate. However, in make,
#	a rule is like a function definition and a call all in one. That's why as long as the dependencies are met,
#	when the rule is first encountered, it is run.

#note on @:
#	'@' allows for 'silent execution' -- it suppresses the printing/echoing of the following
#	command when used in a rule.
#	E.g.:
#	all:
#		@cho "Building project..."
#		gcc -o main main.c
#	^^This will print "Building project..." but will not allow the following command,
#	"gcc -o main main.c", to echo or print anything and thus it will run silently
$(ODIR)/%.o: $(SDIR)/%.cpp $(DEPS)
	@mkdir -p $(ODIR)
	$(CC) -c -o $@ $< $(CFLAGS) -I$(PYTHON_INCLUDE) -I$(NUMPY_INCLUDE)

main: $(OBJ)
	$(CC) -o $@ $^ $(CFLAGS) $(LIBS) -L$(PYTHON_LIB)

.PHONY: clean

clean:
	rm -f $(ODIR)/*.o main